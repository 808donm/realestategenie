import crypto from 'crypto';

/**
 * Security tokens for open house QR code access control
 *
 * Uses HMAC-SHA256 to create cryptographically signed tokens that:
 * - Expire after a configurable duration
 * - Can only be generated by the server (requires secret key)
 * - Are tamper-proof (any modification invalidates the signature)
 * - Don't require database storage (stateless)
 */

// Use QR_TOKEN_SECRET if available, otherwise fall back to NEXTAUTH_SECRET
// In production, QR_TOKEN_SECRET should be set for dedicated QR code security
const SECRET_KEY = process.env.QR_TOKEN_SECRET || process.env.NEXTAUTH_SECRET;

if (!SECRET_KEY) {
  throw new Error(
    'QR_TOKEN_SECRET or NEXTAUTH_SECRET must be set in environment variables. ' +
    'Generate a secure random string: openssl rand -base64 32'
  );
}

// Warn once in development if using NEXTAUTH_SECRET instead of dedicated QR_TOKEN_SECRET
let hasWarned = false;
if (!process.env.QR_TOKEN_SECRET && process.env.NEXTAUTH_SECRET && !hasWarned && process.env.NODE_ENV !== 'production') {
  hasWarned = true;
  console.warn('ðŸ’¡ Using NEXTAUTH_SECRET for QR tokens. Consider setting QR_TOKEN_SECRET for better security isolation.');
}

export interface QRTokenPayload {
  eventId: string;
  expiresAt: number; // Unix timestamp in milliseconds
  generatedAt: number; // Unix timestamp in milliseconds
}

/**
 * Generate a signed access token for an open house QR code
 *
 * @param eventId - The open house event ID
 * @param validityHours - How long the token remains valid (default: 72 hours = 3 days)
 * @returns Base64-encoded signed token
 */
export function generateQRToken(eventId: string, validityHours: number = 72): string {
  const now = Date.now();
  const expiresAt = now + (validityHours * 60 * 60 * 1000);

  const payload: QRTokenPayload = {
    eventId,
    expiresAt,
    generatedAt: now,
  };

  // Create payload string: eventId:expiresAt:generatedAt
  const payloadString = `${payload.eventId}:${payload.expiresAt}:${payload.generatedAt}`;

  // Generate HMAC signature
  const signature = crypto
    .createHmac('sha256', SECRET_KEY)
    .update(payloadString)
    .digest('base64url'); // base64url is URL-safe (no +, /, =)

  // Combine payload and signature: payload.signature
  const token = `${Buffer.from(payloadString).toString('base64url')}.${signature}`;

  return token;
}

/**
 * Validate a QR access token
 *
 * @param token - The token to validate
 * @returns Validation result with payload if valid
 */
export function validateQRToken(token: string): {
  valid: boolean;
  payload?: QRTokenPayload;
  error?: string;
} {
  try {
    // Split token into payload and signature
    const parts = token.split('.');
    if (parts.length !== 2) {
      return { valid: false, error: 'Invalid token format' };
    }

    const [payloadEncoded, signature] = parts;

    // Decode payload
    const payloadString = Buffer.from(payloadEncoded, 'base64url').toString('utf-8');
    const [eventId, expiresAtStr, generatedAtStr] = payloadString.split(':');

    if (!eventId || !expiresAtStr || !generatedAtStr) {
      return { valid: false, error: 'Invalid token payload' };
    }

    // Verify signature
    const expectedSignature = crypto
      .createHmac('sha256', SECRET_KEY)
      .update(payloadString)
      .digest('base64url');

    if (signature !== expectedSignature) {
      return { valid: false, error: 'Invalid signature - token may have been tampered with' };
    }

    // Parse timestamps
    const expiresAt = parseInt(expiresAtStr, 10);
    const generatedAt = parseInt(generatedAtStr, 10);

    if (isNaN(expiresAt) || isNaN(generatedAt)) {
      return { valid: false, error: 'Invalid timestamp in token' };
    }

    // Check expiration
    const now = Date.now();
    if (now > expiresAt) {
      const expiredDate = new Date(expiresAt).toISOString();
      return { valid: false, error: `Token expired on ${expiredDate}` };
    }

    // All checks passed
    return {
      valid: true,
      payload: {
        eventId,
        expiresAt,
        generatedAt,
      },
    };
  } catch (error: any) {
    return { valid: false, error: `Token validation error: ${error.message}` };
  }
}

/**
 * Check if a token is valid for a specific event
 *
 * @param token - The token to validate
 * @param expectedEventId - The event ID the token should be for
 * @returns True if valid and matches event ID
 */
export function isValidQRTokenForEvent(token: string, expectedEventId: string): boolean {
  const result = validateQRToken(token);
  return result.valid && result.payload?.eventId === expectedEventId;
}

/**
 * Get remaining validity time for a token
 *
 * @param token - The token to check
 * @returns Remaining time in milliseconds, or null if invalid/expired
 */
export function getTokenRemainingTime(token: string): number | null {
  const result = validateQRToken(token);
  if (!result.valid || !result.payload) {
    return null;
  }

  const now = Date.now();
  const remaining = result.payload.expiresAt - now;
  return remaining > 0 ? remaining : null;
}
